<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exemplo de CSS de Bloqueio de Renderização</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        /*  Crucial:  Estes são os estilos que demonstrarão o bloqueio de renderização.
            Nós os incluímos *inline* para mostrar o impacto imediato, mas no
            JavaScript, também adicionaremos/removeremos dinamicamente atributos de mídia para
            folhas de estilo externas para ver a diferença.
        */
        .not-blocked {
          /* Estilos que devem SEMPRE ser aplicados imediatamente (ou muito rápido) */
          color: green; /* Exemplo: um estilo básico que não deve bloquear */
        }
    </style>

    <!--
       MUITO IMPORTANTE: Estes arquivos CSS externos são *INTENCIONALMENTE* grandes
       (usando Tailwind e Bootstrap) para exagerar o efeito de bloqueio de renderização
       para fins de demonstração.  Em um cenário do mundo real, você NÃO
       gostaria de incluir arquivos CSS tão grandes e não otimizados diretamente.
       O atributo `media` nesses links será manipulado dinamicamente.
    -->
    <link id="tailwind-link" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
    <link id="bootstrap-link" rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">


</head>
<body>

    <h1>Render Blocking CSS</h1>

    <p>
        Tente redimensionar a largura da janela para <strong>menos</strong>
    </p>

    <script>
        // Função para medir o tempo de pintura
        function measurePaintTiming() {
            if (window.performance && window.performance.getEntriesByType) {
                const paintEntries = window.performance.getEntriesByType("paint");

                paintEntries.forEach(entry => {
                    console.log(`${entry.name}: ${entry.startTime}ms`);

                    // Adiciona os resultados à página (opcional)
                    const resultsDiv = document.getElementById("results");
                    if (resultsDiv) {
                        const p = document.createElement("p");
                        p.textContent = `${entry.name}: ${entry.startTime.toFixed(2)}ms`;
                        resultsDiv.appendChild(p);
                    }
                });
            } else {
                console.log("Performance API (paint timing) não suportada.");
            }
        }

         // Função para obter o tempo de carregamento do DOM
        function getDOMLoadTime() {
            if (document.readyState === 'loading') {
                //Se a página ainda está carregando...
                return new Promise(resolve => {
                    document.addEventListener('DOMContentLoaded', () => resolve(performance.now()));
                });
            } else {
                return Promise.resolve(performance.now());
            }
        }

        // Aguarda o evento DOMContentLoaded e chama measurePaintTiming
          getDOMLoadTime().then(() => {
                //Pequeno delay para garantir que o CSS seja carregado e a pintura aconteça.  Em um teste real,
                //você usaria um evento mais robusto, como window.onload, ou observaria mudanças específicas no DOM.
               setTimeout(measurePaintTiming, 0);
          });


        //Função para simular o bloqueio/desbloqueio de renderização
        function toggleRenderBlocking(block) {
            const tailwindLink = document.getElementById("tailwind-link");
            const bootstrapLink = document.getElementById("bootstrap-link");


             if (block) {
                // Torna o CSS *bloqueador* (comportamento padrão)
                tailwindLink.media = "all"; // ou apenas remova o atributo media
                bootstrapLink.media = "all";
            } else {
                 //Torna o CSS *não bloqueador*
                tailwindLink.media = "screen and (max-width: 1px)"; // Praticamente nunca corresponderá
                bootstrapLink.media = "screen and (max-width: 1px)";
            }


        }


        //Exemplo de uso:  Execute o teste com e sem bloqueio
        function runTest() {

            // 1. Teste SEM bloqueio de renderização.
            console.log("---- Teste SEM Bloqueio de Renderização ----");
            toggleRenderBlocking(false); // Garante que o CSS *não* está bloqueando
            window.location.reload();   //Recarrega para um teste limpo.
          
            // 2. Teste COM bloqueio de renderização (após um delay, para que a página anterior tenha tempo de carregar).
            setTimeout(() => {
                console.log("---- Teste COM Bloqueio de Renderização ----");
                toggleRenderBlocking(true);  //Torna o CSS bloqueador.
                 window.location.reload();   //Recarrega para um teste limpo.
            }, 7000); // Ajuste o tempo de espera conforme necessário.  7 segundos (7000ms) devem ser suficientes.

           
        }

        // Adiciona os resultados à página (opcional):
        const resultsDiv = document.createElement("div");
        resultsDiv.id = "results";
        document.body.appendChild(resultsDiv);

        //Executa o teste ao carregar a página.
        // window.onload = runTest; // Forma mais segura de garantir que tudo foi carregado.
        runTest();  //Chama diretamente para facilitar o teste.  Em produção, use window.onload.

    </script>
</body>
</html>
